-- DDL 15)
-- TERM_NO -> 2008, 2007, 2006
-- CLASS_NO 별
-- STUDENT_NO의 수
CREATE OR REPLACE VIEW POP_CLASS (과목번호, 과목이름, 누적수강생수)
AS (SELECT CLASS_NO, CLASS_NAME, COUNT(*)
    FROM TB_CLASS
    JOIN TB_GRADE USING(CLASS_NO)
    GROUP BY CLASS_NO) --/ not a GROUP BY expression
ORDER BY TERM_NO DESC;
    
SELECT CLASS_NO, CLASS_NAME, 학생수
FROM 

-- 함수 3)
SELECT PROFESSOR_NAME AS "교수 이름", 
        ABS(EXTRACT(YEAR FROM SYSDATE) - EXTRACT(YEAR FROM TO_DATE(SUBSTR(PROFESSOR_SSN, 1, 2), 'YY'))) AS "나이"
FROM TB_PROFESSOR
ORDER BY "나이";

-- 함수 5)
SELECT STUDENT_NO, STUDENT_NAME
FROM TB_STUDENT
WHERE SUBSTR(STUDENT_SSN, 1, 2) + 20 >= EXTRACT(YEAR FROM ENTRANCE_DATE);

-- 함수 13) : COUNT 안 된 행까지 전부 출력하려면?
SELECT DEPARTMENT_NO, NVL(COUNT(*), 0)
FROM TB_STUDENT
WHERE ABSENCE_YN = 'Y'
GROUP BY DEPARTMENT_NO
ORDER BY DEPARTMENT_NO;

SELECT DEPARTMENT_NO, NVL(휴학생수, 0)
FROM (SELECT DEPARTMENT_NO, COUNT(*) AS "휴학생수"
        FROM TB_STUDENT
    WHERE ABSENCE_YN = 'Y'
    GROUP BY DEPARTMENT_NO
    ORDER BY DEPARTMENT_NO)
LEFT JOIN TB_DEPARTMENT USING (DEPARTMENT_NO);

SELECT DEPARTMENT_NO, COUNT(*)
FROM TB_STUDENT
WHERE ABSENCE_YN = 'Y'
AND DEPARTMENT_NO = '002'
GROUP BY DEPARTMENT_NO
ORDER BY DEPARTMENT_NO;

SELECT DEPARTMENT_NO, NVL(COACH_PROFESSOR_NO, 0)
FROM TB_STUDENT
ORDER BY DEPARTMENT_NO;

-- 함수 15)
SELECT TERM_NO, POINT
FROM TB_GRADE
WHERE STUDENT_NO = 'A112113';

SELECT SUBSTR(TERM_NO, 1, 4) AS "년도", AVG(POINT) AS "평점"
FROM TB_GRADE
WHERE STUDENT_NO = 'A112113'
GROUP BY SUBSTR(TERM_NO, 1, 4)
ORDER BY SUBSTR(TERM_NO, 1, 4);

-- 옵션 9)
-- 9)
SELECT CLASS_NAME, PROFESSOR_NAME
FROM (SELECT CLASS_NAME, PROFESSOR_NAME
        FROM TB_CLASS
        JOIN TB_PROFESSOR USING (DEPARTMENT_NO))
JOIN TB_DEPARTMENT USING (DEPARTMENT_NO)
WHERE CATEGORY = '인문사회'; --/ invalid identifier

CREATE OR REPLACE VIEW VW_CP
AS (SELECT CLASS_NAME, PROFESSOR_NAME
    FROM TB_CLASS C, TB_PROFESSOR F
    WHERE C.DEPARTMENT_NO = F.DEPARTMENT_NO);

SELECT CLASS_NAME, PROFESSOR_NAME
FROM TB_DEPARTMENT D, VW_CP S
WHERE D.DEPARTMENT_NO = S.DEPARTMENT_NO
AND CATEGORY = '인문사회';
--/ 서브쿼리를 넣어도 invalid identifier 오류가 나고,
--/ 뷰로 만들어서 넣어도 같은 오류가 남
--/ JOIN은 테이블끼리만 가능한가?
--/ ...그렇겠지? 실제 데이터를 매칭시켜서 임시 테이블을 만드는 거니까...
--/ 매칭 시킨 결과만을 출력하는 VIEW로는 JOIN 할 수 없는 것 같다.

SELECT CLASS_NAME, PROFESSOR_NAME
FROM TB_CLASS
JOIN TB_PROFESSOR USING (DEPARTMENT_NO)
JOIN TB_DEPARTMENT USING (DEPARTMENT_NO)
WHERE CATEGORY = '인문사회'; -- 결과 412행

-- 옵션 10) 그룹으로 묶어야 나오는 결과와 개별 결과를 어떻게 같이 보여주지?
SELECT STUDENT_NO, STUDENT_NAME, "전체 평점"

-- 옵션 14)
SELECT STUDENT_NAME AS "학생이름", 
       NVL(PROFESSOR_NAME, '지도교수 미지정') AS "지도교수"
FROM TB_STUDENT
LEFT JOIN TB_PROFESSOR USING (DEPARTMENT_NO)
JOIN TB_DEPARTMENT USING (DEPARTMENT_NO)
WHERE DEPARTMENT_NAME = '서반아어학과'
ORDER BY STUDENT_NO DESC;

SELECT STUDENT_NAME AS "학생이름", 
       NVL(PROFESSOR_NAME, '지도교수 미지정') AS "지도교수"
FROM TB_STUDENT
LEFT JOIN TB_PROFESSOR ON (COACH_PROFESSOR_NO = PROFESSOR_NO)
JOIN TB_DEPARTMENT USING (DEPARTMENT_NO);
--/ column ambiguously defined

SELECT *
FROM TB_STUDENT
LEFT JOIN TB_PROFESSOR ON (COACH_PROFESSOR_NO = PROFESSOR_NO);
-- DEPARTMENT_NO을 사용하지 않은 시점에서 이미 같은 컬럼이 두 개 생김

SELECT STUDENT_NAME AS "학생이름", 
       NVL(PROFESSOR_NAME, '지도교수 미지정') AS "지도교수"
FROM TB_STUDENT S
LEFT JOIN TB_PROFESSOR P ON (S.COACH_PROFESSOR_NO = P.PROFESSOR_NO)
JOIN TB_DEPARTMENT D ON (S.DEPARTMENT_NO = D.DEPARTMENT_NO);
-- 각자 별칭을 지어줘서 중복되는 DEPARTMENT_NO 중에서도 어떤 컬럼과 매칭 시켜줄지 정해줘야 함

SELECT STUDENT_NAME AS "학생이름", 
       NVL(PROFESSOR_NAME, '지도교수 미지정') AS "지도교수"
FROM TB_STUDENT S
LEFT JOIN TB_PROFESSOR P ON (S.COACH_PROFESSOR_NO = P.PROFESSOR_NO)
JOIN TB_DEPARTMENT D ON (S.DEPARTMENT_NO = D.DEPARTMENT_NO)
WHERE DEPARTMENT_NAME = '서반아어학과'
ORDER BY STUDENT_ID DESC; -- 학번이 알파벳이 끼어 있어서 값끼리 비교가 안 됨

SELECT STUDENT_NAME AS "학생이름", 
       NVL(PROFESSOR_NAME, '지도교수 미지정') AS "지도교수"
FROM TB_STUDENT S
LEFT JOIN TB_PROFESSOR P ON (S.COACH_PROFESSOR_NO = P.PROFESSOR_NO)
JOIN TB_DEPARTMENT D ON (S.DEPARTMENT_NO = D.DEPARTMENT_NO)
WHERE DEPARTMENT_NAME = '서반아어학과'
ORDER BY ENTRANCE_DATE;

-- 옵션 15) 아니 평점을 어케 다른 거랑 섞냐고...